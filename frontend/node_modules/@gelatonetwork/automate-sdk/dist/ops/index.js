"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GelatoOpsSDK = void 0;
require("ethers");
const abstract_signer_1 = require("@ethersproject/abstract-signer");
const constants_1 = require("../constants");
const types_1 = require("../contracts/types");
const axios_1 = __importDefault(require("axios"));
const utils_1 = require("../utils");
class GelatoOpsSDK {
    //private _abiEncoder: utils.AbiCoder;
    constructor(chainId, signer) {
        if (!(0, utils_1.isGelatoOpsSupported)(chainId)) {
            throw new Error(`Gelato Ops is not available on chainId:${chainId}`);
        }
        if (!abstract_signer_1.Signer.isSigner(signer)) {
            throw new Error(`Invalid Gelato Ops signer`);
        }
        this._chainId = chainId;
        this._signer = signer;
        this._ops = types_1.Ops__factory.connect(constants_1.GELATO_OPS_ADDRESSES[this._chainId], this._signer);
    }
    getActiveTasks() {
        return __awaiter(this, void 0, void 0, function* () {
            // Retrieve user task ids
            const address = yield this._signer.getAddress();
            const taskIds = yield this._ops.getTaskIdsByUser(address);
            // Retrieve task names
            const path = `/tasks/${this._chainId}/getTasksByTaskIds`;
            const tasksNames = yield this._postTaskApi(path, {
                taskIds,
            });
            console.log(tasksNames);
            // Build results
            const tasks = [];
            for (const taskId of taskIds) {
                const taskName = tasksNames === null || tasksNames === void 0 ? void 0 : tasksNames.find((t) => t.taskId === taskId);
                tasks.push({
                    taskId,
                    name: taskName ? taskName.name : taskId,
                });
            }
            return tasks;
        });
    }
    createTask(executorAddress, executorSelector, resolverAddress, resolverData, name) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            // Create task on chain
            const tx = yield this._ops.createTask(executorAddress, executorSelector, resolverAddress, resolverData);
            const taskReceipt = yield tx.wait();
            // Retrieve taskId from TaskCreated event
            const taskCreated = (_a = taskReceipt.events) === null || _a === void 0 ? void 0 : _a.find((e) => e.event === "TaskCreated");
            if (taskCreated && ((_b = taskCreated.args) === null || _b === void 0 ? void 0 : _b.taskId)) {
                const taskId = taskCreated.args.taskId;
                taskReceipt.taskId = taskId;
                // And post task name to tasks API
                yield this._createTaskName(taskId, name !== null && name !== void 0 ? name : taskId);
            }
            return taskReceipt;
        });
    }
    cancelTask(taskId) {
        return __awaiter(this, void 0, void 0, function* () {
            const tx = yield this._ops.cancelTask(taskId);
            return yield tx.wait();
        });
    }
    _createTaskName(taskId, name) {
        return __awaiter(this, void 0, void 0, function* () {
            const path = `/tasks/${this._chainId}`;
            yield this._postTaskApi(path, { taskId, name, chainId: this._chainId });
        });
    }
    renameTask(taskId, name) {
        return __awaiter(this, void 0, void 0, function* () {
            const path = `/tasks/${this._chainId}/${taskId}`;
            yield this._postTaskApi(path, { name });
        });
    }
    _postTaskApi(path, data) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const message = "Gelato Ops Task";
                const signature = yield this._signer.signMessage(message);
                const token = Buffer.from(JSON.stringify({ signature, message })).toString("base64");
                const response = yield axios_1.default.post(`${constants_1.OPS_TASKS_API}${path}`, data, {
                    headers: {
                        Authorization: `Bearer ${token}`,
                    },
                });
                return response.data;
            }
            catch (error) {
                this._logTaskApiError(error);
                return undefined;
            }
        });
    }
    _logTaskApiError(error) {
        var _a, _b;
        // Task API error are logged but not thrown as they are non blocking
        let message = `GelatoOpsSDK - Error naming task: ${error.message} `;
        if (axios_1.default.isAxiosError(error)) {
            message += (_b = (_a = error.response) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.message;
        }
        console.error(message);
    }
}
exports.GelatoOpsSDK = GelatoOpsSDK;
