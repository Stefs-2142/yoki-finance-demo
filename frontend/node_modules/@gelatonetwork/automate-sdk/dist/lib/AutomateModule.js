"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AutomateModule = void 0;
/* eslint-disable @typescript-eslint/naming-convention */
/* eslint-disable no-empty */
const ethers_1 = require("ethers");
const Module_interface_1 = require("../types/Module.interface");
class AutomateModule {
    constructor() {
        this.encodeModuleArgs = (moduleArgsParams) => {
            const modules = [];
            const args = [];
            const { resolverAddress, resolverData, startTime, interval, dedicatedMsgSender, singleExec, } = moduleArgsParams;
            if (resolverAddress && resolverData) {
                modules.push(Module_interface_1.Module.RESOLVER);
                args.push(this.encodeResolverArgs(resolverAddress, resolverData));
            }
            if (interval) {
                const start = startTime !== null && startTime !== void 0 ? startTime : 0;
                modules.push(Module_interface_1.Module.TIME);
                args.push(this.encodeTimeArgs(start, interval));
            }
            else {
                if (singleExec && startTime) {
                    modules.push(Module_interface_1.Module.TIME);
                    args.push(this.encodeTimeArgs(startTime, 1));
                }
            }
            if (dedicatedMsgSender) {
                modules.push(Module_interface_1.Module.PROXY);
                args.push("0x");
            }
            if (singleExec) {
                modules.push(Module_interface_1.Module.SINGLE_EXEC);
                args.push("0x");
            }
            return { modules, args };
        };
        this.decodeModuleArgs = (moduleData) => {
            const modules = moduleData.modules;
            const args = moduleData.args;
            const moduleArgsDecoded = {
                resolverAddress: null,
                resolverData: null,
                startTime: null,
                interval: null,
                dedicatedMsgSender: false,
                singleExec: false,
            };
            if (modules.includes(Module_interface_1.Module.RESOLVER)) {
                const indexOfModule = modules.indexOf(Module_interface_1.Module.RESOLVER);
                const { resolverAddress, resolverData } = this.decodeResolverArgs(args[indexOfModule]);
                moduleArgsDecoded.resolverAddress = resolverAddress;
                moduleArgsDecoded.resolverData = resolverData;
            }
            if (modules.includes(Module_interface_1.Module.TIME)) {
                const indexOfModule = modules.indexOf(Module_interface_1.Module.TIME);
                const { startTime, interval } = this.decodeTimeArgs(args[indexOfModule]);
                moduleArgsDecoded.startTime = startTime;
                moduleArgsDecoded.interval = interval;
            }
            if (modules.includes(Module_interface_1.Module.PROXY)) {
                moduleArgsDecoded.dedicatedMsgSender = true;
            }
            if (modules.includes(Module_interface_1.Module.SINGLE_EXEC)) {
                moduleArgsDecoded.singleExec = true;
            }
            return moduleArgsDecoded;
        };
        this.encodeResolverArgs = (resolverAddress, resolverData) => {
            const encoded = ethers_1.ethers.utils.defaultAbiCoder.encode(["address", "bytes"], [resolverAddress, resolverData]);
            return encoded;
        };
        this.decodeResolverArgs = (encodedModuleArgs) => {
            let resolverAddress = null;
            let resolverData = null;
            try {
                [resolverAddress, resolverData] = ethers_1.ethers.utils.defaultAbiCoder.decode(["address", "bytes"], encodedModuleArgs);
            }
            catch (_a) { }
            return { resolverAddress, resolverData };
        };
        this.encodeTimeArgs = (startTime, interval) => {
            const encoded = ethers_1.ethers.utils.defaultAbiCoder.encode(["uint128", "uint128"], [startTime, interval]);
            return encoded;
        };
        this.decodeTimeArgs = (encodedModuleArgs) => {
            let startTime = null;
            let interval = null;
            try {
                [startTime, interval] = ethers_1.ethers.utils.defaultAbiCoder.decode(["uint128", "uint128"], encodedModuleArgs);
            }
            catch (_a) { }
            return { startTime, interval };
        };
    }
}
exports.AutomateModule = AutomateModule;
