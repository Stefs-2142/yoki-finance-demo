"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GelatoOpsModule = void 0;
/* eslint-disable @typescript-eslint/naming-convention */
/* eslint-disable no-empty */
const ethers_1 = require("ethers");
const types_1 = require("../types");
const Web3FunctionDownloader_1 = require("./Web3Function/Web3FunctionDownloader");
class GelatoOpsModule {
    constructor() {
        this.encodeModuleArgs = (moduleArgsParams) => __awaiter(this, void 0, void 0, function* () {
            const modules = [];
            const args = [];
            const { resolverAddress, resolverData, startTime, interval, dedicatedMsgSender, singleExec, web3FunctionHash, web3FunctionArgs, web3FunctionArgsHex, } = moduleArgsParams;
            if (resolverAddress && resolverData) {
                modules.push(types_1.Module.RESOLVER);
                args.push(this.encodeResolverArgs(resolverAddress, resolverData));
            }
            if (interval) {
                const start = startTime !== null && startTime !== void 0 ? startTime : 0;
                modules.push(types_1.Module.TIME);
                args.push(this.encodeTimeArgs(start, interval));
            }
            if (dedicatedMsgSender) {
                modules.push(types_1.Module.PROXY);
                args.push("0x");
            }
            if (singleExec) {
                modules.push(types_1.Module.SINGLE_EXEC);
                args.push("0x");
            }
            if (web3FunctionHash && web3FunctionArgsHex) {
                modules.push(types_1.Module.WEB3_FUNCTION);
                args.push(yield this.encodeWeb3FunctionArgs(web3FunctionHash, undefined, web3FunctionArgsHex));
            }
            else if (web3FunctionHash && web3FunctionArgs) {
                modules.push(types_1.Module.WEB3_FUNCTION);
                args.push(yield this.encodeWeb3FunctionArgs(web3FunctionHash, web3FunctionArgs));
            }
            return { modules, args };
        });
        this.decodeModuleArgs = (moduleData) => __awaiter(this, void 0, void 0, function* () {
            const modules = moduleData.modules;
            const args = moduleData.args;
            const moduleArgsDecoded = {
                resolverAddress: null,
                resolverData: null,
                startTime: null,
                interval: null,
                dedicatedMsgSender: false,
                singleExec: false,
                web3FunctionHash: null,
                web3FunctionArgs: null,
                web3FunctionArgsHex: null,
            };
            if (modules.includes(types_1.Module.RESOLVER)) {
                const indexOfModule = modules.indexOf(types_1.Module.RESOLVER);
                const { resolverAddress, resolverData } = this.decodeResolverArgs(args[indexOfModule]);
                moduleArgsDecoded.resolverAddress = resolverAddress;
                moduleArgsDecoded.resolverData = resolverData;
            }
            if (modules.includes(types_1.Module.TIME)) {
                const indexOfModule = modules.indexOf(types_1.Module.TIME);
                const { startTime, interval } = this.decodeTimeArgs(args[indexOfModule]);
                moduleArgsDecoded.startTime = startTime;
                moduleArgsDecoded.interval = interval;
            }
            if (modules.includes(types_1.Module.PROXY)) {
                moduleArgsDecoded.dedicatedMsgSender = true;
            }
            if (modules.includes(types_1.Module.SINGLE_EXEC)) {
                moduleArgsDecoded.singleExec = true;
            }
            if (modules.includes(types_1.Module.WEB3_FUNCTION)) {
                const indexOfModule = modules.indexOf(types_1.Module.WEB3_FUNCTION);
                const { web3FunctionHash, web3FunctionArgs, web3FunctionArgsHex } = yield this.decodeWeb3FunctionArgs(args[indexOfModule]);
                moduleArgsDecoded.web3FunctionHash = web3FunctionHash;
                moduleArgsDecoded.web3FunctionArgs = web3FunctionArgs;
                moduleArgsDecoded.web3FunctionArgsHex = web3FunctionArgsHex;
            }
            return moduleArgsDecoded;
        });
        this.encodeResolverArgs = (resolverAddress, resolverData) => {
            const encoded = ethers_1.ethers.utils.defaultAbiCoder.encode(["address", "bytes"], [resolverAddress, resolverData]);
            return encoded;
        };
        this.decodeResolverArgs = (encodedModuleArgs) => {
            let resolverAddress = null;
            let resolverData = null;
            try {
                [resolverAddress, resolverData] = ethers_1.ethers.utils.defaultAbiCoder.decode(["address", "bytes"], encodedModuleArgs);
            }
            catch (_a) { }
            return { resolverAddress, resolverData };
        };
        this.encodeTimeArgs = (startTime, interval) => {
            const encoded = ethers_1.ethers.utils.defaultAbiCoder.encode(["uint128", "uint128"], [startTime, interval]);
            return encoded;
        };
        this.decodeTimeArgs = (encodedModuleArgs) => {
            let startTime = null;
            let interval = null;
            try {
                [startTime, interval] = ethers_1.ethers.utils.defaultAbiCoder.decode(["uint128", "uint128"], encodedModuleArgs);
            }
            catch (_a) { }
            return { startTime, interval };
        };
        this.encodeWeb3FunctionArgs = (web3FunctionHash, web3FunctionArgs, web3FunctionArgsHex) => __awaiter(this, void 0, void 0, function* () {
            try {
                if (!web3FunctionArgsHex && web3FunctionArgs) {
                    const { types, keys } = yield this.getAbiTypesAndKeysFromSchema(web3FunctionHash);
                    // ensure all userArgs are provided & encoded in same order as they are defined in the schema
                    const values = [];
                    for (const key of keys) {
                        if (typeof web3FunctionArgs[key] === "undefined") {
                            throw new Error(`Missing user arg '${key}' defined in resolver schema`);
                        }
                        values.push(web3FunctionArgs[key]);
                    }
                    web3FunctionArgsHex = ethers_1.ethers.utils.defaultAbiCoder.encode(types, values);
                }
                const encoded = ethers_1.ethers.utils.defaultAbiCoder.encode(["string", "bytes"], [web3FunctionHash, web3FunctionArgsHex]);
                return encoded;
            }
            catch (err) {
                throw new Error(`Fail to encode Web3Function: ${err.message}`);
            }
        });
        this.decodeWeb3FunctionArgs = (encodedModuleArgs) => __awaiter(this, void 0, void 0, function* () {
            let web3FunctionHash = null;
            let web3FunctionArgs = null;
            let web3FunctionArgsHex = null;
            try {
                [web3FunctionHash, web3FunctionArgsHex] =
                    ethers_1.ethers.utils.defaultAbiCoder.decode(["string", "bytes"], encodedModuleArgs);
                web3FunctionArgs = yield this.decodeWeb3FunctionArgsHex(web3FunctionArgsHex, {
                    web3FunctionHash: web3FunctionHash,
                });
            }
            catch (err) {
                console.error(`Fail to decode Web3FunctionArgs: ${err.message}`);
            }
            return { web3FunctionHash, web3FunctionArgs, web3FunctionArgsHex };
        });
        this.decodeWeb3FunctionArgsHex = (web3FunctionArgsHex, schema) => __awaiter(this, void 0, void 0, function* () {
            try {
                let schemaAbi;
                const web3FunctionArgs = {};
                if (schema.web3FunctionHash)
                    schemaAbi = yield this.getAbiTypesAndKeysFromSchema(schema.web3FunctionHash);
                else
                    schemaAbi = yield this.getAbiTypesAndKeysFromSchema(undefined, schema.userArgsSchema);
                const { types, keys } = schemaAbi;
                const web3FunctionArgsValues = ethers_1.ethers.utils.defaultAbiCoder.decode(types, web3FunctionArgsHex);
                // decode argument according to schema key order
                keys.forEach((key, idx) => (web3FunctionArgs[key] = web3FunctionArgsValues[idx]));
                return web3FunctionArgs;
            }
            catch (err) {
                console.error(`Fail to decode Web3FunctionArgsHex: ${err.message}`);
                return null;
            }
        });
        this._hexToBuffer = (hexString) => {
            const noPrefix = hexString.slice(2);
            const buffer = Uint8Array.from(Buffer.from(noPrefix, "hex"));
            return buffer;
        };
        this._bufferToHex = (buffer) => {
            const hex = [...new Uint8Array(buffer)]
                .map((b) => b.toString(16).padStart(2, "0"))
                .join("");
            const hexPrefixed = "0x" + hex;
            return hexPrefixed;
        };
        this.getAbiTypesAndKeysFromSchema = (web3FunctionHash, _userArgsSchema) => __awaiter(this, void 0, void 0, function* () {
            try {
                let userArgsSchema = _userArgsSchema;
                if (!userArgsSchema) {
                    if (web3FunctionHash) {
                        const downloader = new Web3FunctionDownloader_1.Web3FunctionDownloader();
                        const schema = yield downloader.fetchSchema(web3FunctionHash);
                        userArgsSchema = schema.userArgs;
                    }
                    else
                        throw new Error(`Both userArgsSchema && web3FunctionHash undefined`);
                }
                const types = [];
                const keys = [];
                Object.keys(userArgsSchema).forEach((key) => {
                    if (!userArgsSchema || !userArgsSchema[key])
                        return;
                    keys.push(key);
                    const value = userArgsSchema[key];
                    switch (value) {
                        case "number":
                            types.push("uint256");
                            break;
                        case "string":
                            types.push("string");
                            break;
                        case "boolean":
                            types.push("bool");
                            break;
                        case "number[]":
                            types.push("uint256[]");
                            break;
                        case "string[]":
                            types.push("string[]");
                            break;
                        case "boolean[]":
                            types.push("bool[]");
                            break;
                        default:
                            throw new Error(`Invalid schema in web3Function CID: ${web3FunctionHash}. Invalid type ${value}. userArgsSchema: ${userArgsSchema}`);
                    }
                });
                return { types, keys };
            }
            catch (err) {
                throw new Error(`Fail to get types from schema: ${err.message}`);
            }
        });
    }
}
exports.GelatoOpsModule = GelatoOpsModule;
