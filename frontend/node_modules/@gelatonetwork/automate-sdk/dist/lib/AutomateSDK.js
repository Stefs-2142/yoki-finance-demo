"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AutomateSDK = void 0;
/* eslint-disable no-prototype-builtins */
require("ethers");
const abstract_signer_1 = require("@ethersproject/abstract-signer");
const constants_1 = require("../constants");
const types_1 = require("../contracts/types");
const ethers_1 = require("ethers");
const axios_1 = __importDefault(require("axios"));
const utils_1 = require("../utils");
const Module_interface_1 = require("../types/Module.interface");
const AutomateModule_1 = require("./AutomateModule");
class AutomateSDK {
    constructor(chainId, signer, signatureMessage) {
        this.isGnosisSafeApp = () => {
            var _a;
            let provider;
            if ((_a = this._signer.provider) === null || _a === void 0 ? void 0 : _a.hasOwnProperty("provider")) {
                // Use internal provider
                provider = this._signer.provider.provider;
            }
            else {
                provider = this._signer.provider;
            }
            return Boolean(provider === null || provider === void 0 ? void 0 : provider.hasOwnProperty("safe"));
        };
        if (!(0, utils_1.isAutomateSupported)(chainId)) {
            throw new Error(`Automate is not available on chainId:${chainId}`);
        }
        if (!abstract_signer_1.Signer.isSigner(signer)) {
            throw new Error(`Invalid Automate signer`);
        }
        this._automateModule = new AutomateModule_1.AutomateModule();
        this._signatureMessage = signatureMessage !== null && signatureMessage !== void 0 ? signatureMessage : "Automate Task";
        this._chainId = chainId;
        this._signer = signer;
        this._automate = types_1.Automate__factory.connect(constants_1.GELATO_ADDRESSES[this._chainId].automate, this._signer);
        this._taskApi = axios_1.default.create({ baseURL: constants_1.AUTOMATE_TASKS_API });
    }
    getActiveTasks() {
        return __awaiter(this, void 0, void 0, function* () {
            // Retrieve user task ids
            const address = yield this._signer.getAddress();
            const taskIds = yield this._automate.getTaskIdsByUser(address);
            return this.getTaskNames(taskIds);
        });
    }
    getTaskNames(taskIds) {
        return __awaiter(this, void 0, void 0, function* () {
            // short-circuit if it's clear no taskIds were received
            if (!(taskIds === null || taskIds === void 0 ? void 0 : taskIds.length))
                return [];
            // Retrieve task names
            const path = `/tasks/${this._chainId}/getTasksByTaskIds`;
            const tasksNames = yield this._postTaskApi(path, {
                taskIds,
            }, true // used to skip signature
            );
            // Build results
            const tasks = [];
            for (const taskId of taskIds) {
                const taskName = tasksNames === null || tasksNames === void 0 ? void 0 : tasksNames.find((t) => t.taskId === taskId);
                tasks.push({
                    taskId,
                    name: taskName ? taskName.name : taskId,
                });
            }
            return tasks;
        });
    }
    getDedicatedMsgSender() {
        return __awaiter(this, void 0, void 0, function* () {
            const proxyModuleAddress = yield this._automate.taskModuleAddresses(Module_interface_1.Module.PROXY);
            const automateProxyFactoryAddress = yield types_1.ProxyModule__factory.connect(proxyModuleAddress, this._signer).opsProxyFactory();
            const automateProxyFactory = types_1.AutomateProxyFactory__factory.connect(automateProxyFactoryAddress, this._signer);
            const userAddress = yield this._signer.getAddress();
            const [address, isDeployed] = yield automateProxyFactory.getProxyOf(userAddress);
            return { address, isDeployed };
        });
    }
    getTaskId(_args) {
        return __awaiter(this, void 0, void 0, function* () {
            const args = this._processModules(_args);
            return this._getTaskId(args);
        });
    }
    _getTaskId(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const address = yield this._signer.getAddress();
            const modules = args.moduleData.modules;
            if ((modules.length === 1 && modules[0] === Module_interface_1.Module.RESOLVER) ||
                (modules.length === 2 &&
                    modules[0] === Module_interface_1.Module.RESOLVER &&
                    modules[1] === Module_interface_1.Module.TIME))
                return this._getLegacyTaskId(args);
            const taskId = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.defaultAbiCoder.encode([
                "address",
                "address",
                "bytes4",
                "tuple(uint8[] modules,bytes[] args)",
                "address",
            ], [
                address,
                args.execAddress,
                args.execSelector,
                args.moduleData,
                args.useTreasury ? ethers_1.ethers.constants.AddressZero : constants_1.ETH,
            ]));
            return taskId;
        });
    }
    _getLegacyTaskId(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const address = yield this._signer.getAddress();
            const resolverHash = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.defaultAbiCoder.encode(["address", "bytes"], [args.resolverAddress, args.resolverData]));
            const taskId = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.defaultAbiCoder.encode(["address", "address", "bytes4", "bool", "address", "bytes32"], [
                address,
                args.execAddress,
                args.execSelector,
                args.useTreasury,
                args.useTreasury ? ethers_1.ethers.constants.AddressZero : constants_1.ETH,
                resolverHash,
            ]));
            return taskId;
        });
    }
    createTask(_args, overrides = {}) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const args = this._processModules(_args);
            // Ask for signature
            if (!this._token)
                yield this._requestAndStoreSignature();
            const tx = yield this._automate.createTask(args.execAddress, (_a = args.execData) !== null && _a !== void 0 ? _a : args.execSelector, args.moduleData, args.useTreasury ? constants_1.ZERO_ADD : constants_1.ETH, overrides);
            const taskId = yield this._getTaskId(args);
            yield this._finalizeTaskCreation(taskId, args);
            return { taskId, tx };
        });
    }
    _processModules(args) {
        var _a, _b;
        args.startTime = (_a = args.startTime) !== null && _a !== void 0 ? _a : 0;
        const moduleData = this._automateModule.encodeModuleArgs({
            resolverAddress: args.resolverAddress,
            resolverData: args.resolverData,
            startTime: args.startTime,
            interval: args.interval,
            dedicatedMsgSender: args.dedicatedMsgSender,
            singleExec: args.singleExec,
        });
        return Object.assign(Object.assign({}, args), { useTreasury: (_b = args.useTreasury) !== null && _b !== void 0 ? _b : true, moduleData });
    }
    _finalizeTaskCreation(taskId, args) {
        return __awaiter(this, void 0, void 0, function* () {
            // Post task name & contracts ABI to tasks API
            const { name, execAddress, execAbi, resolverAddress, resolverAbi } = args;
            const promises = [];
            promises.push(this._setTaskName(taskId, name !== null && name !== void 0 ? name : taskId));
            if (execAbi) {
                promises.push(this._setContractAbi(taskId, false, execAddress, execAbi));
            }
            if (resolverAddress && resolverAbi) {
                promises.push(this._setContractAbi(taskId, true, resolverAddress, resolverAbi));
            }
            yield Promise.all(promises);
        });
    }
    cancelTask(taskId, overrides = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const tx = yield this._automate.cancelTask(taskId, overrides);
            return { taskId, tx };
        });
    }
    _requestAndStoreSignature() {
        return __awaiter(this, void 0, void 0, function* () {
            const tokenData = {
                message: this._signatureMessage,
                origin: "SDK",
            };
            if (this.isGnosisSafeApp()) {
                tokenData.unsignedUser = yield this._signer.getAddress();
            }
            else {
                tokenData.signature = yield this._signer.signMessage(this._signatureMessage);
            }
            this._token = Buffer.from(JSON.stringify(tokenData)).toString("base64");
            // Set Axios headers
            this._taskApi.defaults.headers.common["Authorization"] = `Bearer ${this._token}`;
        });
    }
    _setTaskName(taskId, name) {
        return __awaiter(this, void 0, void 0, function* () {
            const path = `/tasks/${this._chainId}`;
            yield this._postTaskApi(path, { taskId, name, chainId: this._chainId });
        });
    }
    renameTask(taskId, name) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isGnosisSafeApp()) {
                throw new Error("Cannot rename task from a gnosis safe");
            }
            const path = `/tasks/${this._chainId}/${taskId}`;
            yield this._postTaskApi(path, { name });
        });
    }
    _setContractAbi(taskId, isResolver, address, abi) {
        return __awaiter(this, void 0, void 0, function* () {
            const path = `/contracts/${this._chainId}/`;
            yield this._postTaskApi(path, {
                chainId: this._chainId,
                taskId,
                address,
                resolver: isResolver,
                ABI: abi,
            });
        });
    }
    _postTaskApi(path, data, skipSignature = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!skipSignature && !this._token) {
                yield this._requestAndStoreSignature();
            }
            try {
                const response = yield this._taskApi.post(`${constants_1.AUTOMATE_TASKS_API}${path}`, data);
                return response.data;
            }
            catch (error) {
                this._logTaskApiError(error);
                return undefined;
            }
        });
    }
    _logTaskApiError(error) {
        var _a, _b;
        // Task API error are logged but not thrown as they are non blocking
        let message = `AutomateSDK - Error naming task: ${error.message} `;
        if (axios_1.default.isAxiosError(error)) {
            message += (_b = (_a = error.response) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.message;
        }
        console.error(message);
    }
}
exports.AutomateSDK = AutomateSDK;
